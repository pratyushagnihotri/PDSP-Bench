{"ast":null,"code":"import axios from 'axios';\nimport CodeEditor from './CodeEditor.vue';\nexport default {\n  name: 'ClusterInfo',\n  components: {\n    CodeEditor\n  },\n  props: {\n    id: String\n  },\n  data() {\n    return {\n      showProgress: false,\n      joblogs: 'Job logs ',\n      url: process.env.VUE_APP_URL,\n      cluster_name: '',\n      cluster_id: '',\n      cluster_status: '',\n      enumeration_strategies: ['None', 'Random', 'Rulebased', 'Exhaustive', 'MinMax', 'Custom'],\n      iteration_strategies: ['From Top', 'From Bottom', 'Random'],\n      job_class: ['Word Count', 'Smart Grid', 'Ad Analytics', 'Google cloud Monitoring', 'Sentiment Analysis', 'Spike Detection', 'Log Processing', 'Trending Topics', 'Bargain Index', 'Click Analytics', 'Machine Outlier', 'Linear Road', 'TPCH', 'Traffic Monitoring'],\n      job_queries: {\n        'Word Count': {\n          query_list: [{\n            id: 1,\n            name: '1. Counting the number of words',\n            operators: ['Source', 'tokenizer', 'Counter', 'Sink'],\n            selectivities: [1, 6, 1, 1],\n            query_plan: 'SELECT count(*) FROM words'\n          }]\n        },\n        'Smart Grid': {\n          query_list: [{\n            id: 1,\n            name: '1. Calculate the global average load of each house',\n            operators: ['source', 'house-event-parser', 'global average load', 'sink'],\n            selectivities: [],\n            // TODO\n            hasWindows: true,\n            query_plan: `SELECT\n    HouseEvent.house,\n    AVG(HouseEvent.load) AS average_load,\n    TUMBLE_START(event_time, INTERVAL slidingWindowSize SECOND) AS window_start,\n    TUMBLE_END(event_time, INTERVAL slidingWindowSize SECOND) AS window_end\nFROM\n    HouseEvent\nGROUP BY  \n    HouseEvent.house,\n    TUMBLE(event_time, INTERVAL slidingWindowSize SECOND) //PARALLELIZATION -- *\n\n`\n          }, {\n            id: 2,\n            name: '2. Calculate the local average load of plugs in each household',\n            operators: ['source', 'house-event-parser', 'local average load', 'sink'],\n            selectivities: [],\n            // TODO\n            hasWindows: true,\n            query_plan: `SELECT\n    HouseEvent.house,\n    HouseEvent.households,\n    HouseEvent.plugs,\n    AVG(HouseEvent.load) AS average_load,\n    TUMBLE_START(event_time, INTERVAL slidingWindowSize SECOND) AS window_start,\n    TUMBLE_END(event_time, INTERVAL slidingWindowSize SECOND) AS window_end\nFROM\n    HouseEvent\nGROUP BY\n    HouseEvent.house,\n    HouseEvent.households,\n    HouseEvent.plugs,\n    TUMBLE(event_time, INTERVAL slidingWindowSize SECOND) //PARALLELIZATION -- *\n`\n          }]\n        },\n        'Ad Analytics': {\n          query_list: [{\n            id: 1,\n            name: '1. Calculate the Ad_analytics query (join)',\n            operators: [\"source\", \"click-parser\", \"impression-parser\", \"clicks-counter\", \"impressions-counter\", \"rollingCTR\", \"sink\"],\n            selectivities: [],\n            // TODO\n            hasWindows: true,\n            query_plan: `-- Step 1: Parse clicks and impressions\nWITH parsed_clicks AS (\n  SELECT query_id, ad_id, COUNT(*) AS click_count\n  FROM clicks\n  GROUP BY query_id, ad_id \n),  //PARALLELIZATION -- *\nparsed_impressions AS (\n  SELECT query_id, ad_id, COUNT(*) AS impression_count\n  FROM impressions\n  GROUP BY query_id, ad_id \n),//PARALLELIZATION -- **\n\n-- Step 2: Calculate CTR\nrolling_ctr AS (\n  SELECT\n    pc.query_id,\n    pc.ad_id,\n    pc.click_count,\n    pi.impression_count,\n    pc.click_count / pi.impression_count AS ctr\n  FROM parsed_clicks pc\n  JOIN parsed_impressions pi ON pc.query_id = pi.query_id AND pc.ad_id = pi.ad_id\n  WHERE pc.click_count <= pi.impression_count\n) //PARALLELIZATION -- ***\n\n-- Step 3: Output the result //PARALLELIZATION -- ****\nSELECT *\nFROM rolling_ctr; //PARALLELIZATION -- *****`\n          }, {\n            id: 2,\n            name: '1. Calculate the Ad_analytics query (no join)',\n            operators: [\"source\", \"parser\", \"counter\", \"rollingCTR\", \"sink\"],\n            selectivities: [],\n            // TODO\n            hasWindows: true,\n            query_plan: ``\n          }]\n        },\n        'Google cloud Monitoring': {\n          query_list: [{\n            id: 1,\n            name: '1. Calculate average-cpu-per-category',\n            operators: [\"source\", \"parser\", \"avg-cpu-per-category\", \"sink\"],\n            selectivities: [],\n            // TODO\n            hasWindows: true,\n            hasLateness: true,\n            query_plan: `SELECT  //PARALLELIZATION -- *\n    category,\n    AVG(cpu_usage) AS avg_cpu_usage\nFROM\n    Google_Cloud_Monitoring_stream\nWHERE\n    event_type = 1\nGROUP BY  //PARALLELIZATION -- **\n    category  \n`\n          }, {\n            id: 2,\n            name: '2. Calculate average-cpu-per-job',\n            operators: [\"source\", \"parser\", \"avg-cpu-per-job\", \"sink\"],\n            selectivities: [],\n            // TODO\n            hasWindows: true,\n            hasLateness: true,\n            query_plan: `SELECT //PARALLELIZATION -- *\n    job_id,\n    AVG(cpu_usage) AS avg_cpu_usage\nFROM\nGoogle_Cloud_Monitoring_stream\nWHERE\n    event_type = 1\nGROUP BY  //PARALLELIZATION -- **\n    job_id  `\n          }]\n        },\n        'Sentiment Analysis': {\n          query_list: [{\n            id: 1,\n            name: '1. Calculate sentiment analysis',\n            operators: [\"source\", \"twitter parser\", \"twitter analyser\", \"sink\"],\n            selectivities: [],\n            // TODO\n            hasWindows: false,\n            query_plan: `SELECT //PARALLELIZATION -- *\n  id,\n  timestamp,\n  text,\n  sentimentResult.sentiment AS sentiment,\n  sentimentResult.score AS sentimentScore\nFROM (\n  SELECT //PARALLELIZATION -- **\n    id,\n    timestamp,\n    text,\n    SentimentClassifierFactory.create(SentimentClassifierFactory.BASIC).classify(text) AS sentimentResult\n  FROM <parsed_tweets_table>\n) AS intermediate\n`\n          }]\n        },\n        'Spike Detection': {\n          query_list: [{\n            id: 1,\n            name: '1. Calculate Spike Detection',\n            operators: [\"source\", \"parser\", \"average calculator\", \"spike detector\", \"sink\"],\n            selectivities: [],\n            // TODO\n            hasWindows: true,\n            hasLateness: true,\n            query_plan: `-- Step 1: Parse the input data\nCREATE TABLE SensorMeasurement (\n  sensorId INT,\n  timestamp TIMESTAMP,\n  value DOUBLE\n);\n\nINSERT INTO SensorMeasurement\nSELECT\n  PARSE_JSON(data).sensorId AS sensorId,\n  PARSE_JSON(data).timestamp AS timestamp,\n  PARSE_JSON(data).value AS value\nFROM inputDataStream; //PARALLELIZATION -- *\n\n-- Step 2: Assign timestamps and watermarks\nCREATE TABLE SensorMeasurementWithWatermarks (\n  sensorId INT,\n  timestamp TIMESTAMP,\n  value DOUBLE,\n  watermark TIMESTAMP\n) WITH (\n  WATERMARK FOR timestamp AS timestamp - INTERVAL 'X' SECOND -- Specify the watermark strategy\n);\n\nINSERT INTO SensorMeasurementWithWatermarks\nSELECT\n  sensorId,\n  timestamp,\n  value,\n  timestamp - INTERVAL 'X' SECOND AS watermark\nFROM SensorMeasurement; //PARALLELIZATION -- **\n\n-- Step 3: Key the stream by sensorId\nCREATE TABLE KeyedSensorMeasurement (\n  sensorId INT,\n  timestamp TIMESTAMP,\n  value DOUBLE,\n  watermark TIMESTAMP\n) WITH (\n  WATERMARK FOR watermark AS watermark\n);\n\nINSERT INTO KeyedSensorMeasurement\nSELECT\n  sensorId,\n  timestamp,\n  value,\n  watermark\nFROM SensorMeasurementWithWatermarks;\n\n-- Step 4: Apply sliding processing time window\nCREATE TABLE WindowedSensorMeasurement AS (\n  SELECT\n    sensorId,\n    TUMBLE_START(timestamp, INTERVAL 'X' SECOND) AS windowStart,\n    TUMBLE_END(timestamp, INTERVAL 'X' SECOND) AS windowEnd,\n    AVG(value) AS averageValue\n  FROM KeyedSensorMeasurement\n  GROUP BY\n    sensorId,\n    TUMBLE(timestamp, INTERVAL 'X' SECOND)\n);\n\n-- Step 5: Filter spikes\nCREATE TABLE DetectedSpikes AS (\n  SELECT\n    sensorId,\n    windowStart,\n    windowEnd,\n    averageValue\n  FROM WindowedSensorMeasurement\n  WHERE ABS(value - averageValue) > 0.03 * averageValue\n); //PARALLELIZATION -- ***\n\n-- Step 6: Sink detected spikes\nINSERT INTO outputSink\nSELECT *\nFROM DetectedSpikes;\n`\n          }]\n        },\n        'Log Processing': {\n          query_list: [{\n            id: 1,\n            name: '1. Volume Counter',\n            operators: ['source', 'log-parser', 'volume counter', 'sink'],\n            selectivities: [],\n            // TODO\n            hasWindows: true,\n            query_plan: `SELECT\n    logTime,\n    COUNT(*) AS visitCount //PARALLELIZATION -- **\nFROM\n    (SELECT\n        logTime\n    FROM\n        LogEventTable\n    WHERE\n        logParserOutput = 'log-parser' //PARALLELIZATION -- *\n    ) AS filteredLogs\nGROUP BY\n    logTime;\n\n`\n          }, {\n            id: 2,\n            name: '2. Status Counter',\n            operators: ['source', 'log-parser', 'status counter', 'sink'],\n            selectivities: [],\n            // TODO\n            hasWindows: true,\n            query_plan: `SELECT\n    statusCode,\n    COUNT(*) AS statusCodeCount //PARALLELIZATION -- **\nFROM\n    (SELECT\n        statusCode\n    FROM\n        LogEventTable\n    WHERE\n        logParserOutput = 'log-parser' //PARALLELIZATION -- *\n    ) AS filteredLogs\nGROUP BY\n    statusCode;\n\n`\n          }]\n        },\n        'Trending Topics': {\n          query_list: [{\n            id: 1,\n            name: '1. Twitter trending topics',\n            operators: ['source', 'twitter-parser', 'topic-extractor', 'topic-popularity-detector', 'sink'],\n            selectivities: [],\n            // TODO\n            hasWindows: true,\n            hasThreshold: true,\n            query_plan: `INSERT INTO Topics (Topic, Count)\nSELECT SUBSTRING_INDEX(SUBSTRING_INDEX(word, ' ', 1), '#', -1) AS topic, COUNT(*) AS count //PARALLELIZATION -- ***\nFROM (\n    SELECT\n        REGEXP_REPLACE(SUBSTRING_INDEX(SUBSTRING_INDEX(t.TweetText, ' ', n.n), ' ', -1), '[^a-zA-Z0-9#]', '') AS word //PARALLELIZATION -- **\n    FROM\n        Tweets t\n    CROSS JOIN\n        (SELECT 1 AS n UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4) n -- Adjust the number of cross joins based on the maximum number of words per tweet\n    WHERE\n        t.TweetText LIKE '%#%' -- Filter tweets containing hashtags\n) subquery\nGROUP BY topic; //PARALLELIZATION -- *\n\n`\n          }]\n        },\n        'Bargain Index': {\n          query_list: [{\n            id: 1,\n            name: '1. Bargain-Index Calculator',\n            operators: [\"source\", \"quote-parser\", \"VWAP-operator\", \"bargain-index-calculator\", \"sink\"],\n            selectivities: [],\n            // TODO\n            hasWindows: true,\n            hasThreshold: true,\n            query_plan: `CREATE VIEW VWAP AS\nSELECT\n    symbol,\n    SUM(close * volume) / SUM(volume) AS vwap,  //PARALLELIZATION -- **\n    SUM(volume) AS totalVolume\nFROM\n    StockQuotes\nGROUP BY\n    symbol;\n\n-- Calculate bargain index and filter quotes\nSET @threshold = 0; -- Set your desired threshold value here  //PARALLELIZATION -- ***\nSELECT\n    q.symbol,\n    q.close,\n    q.volume\nFROM\n    StockQuotes q  //PARALLELIZATION -- *\nJOIN\n    VWAP v ON q.symbol = v.symbol\nWHERE\n    q.close / q.volume > @threshold;\n`\n          }]\n        },\n        'Click Analytics': {\n          query_list: [{\n            id: 1,\n            name: '1. Unique and total visits (timebased window)',\n            operators: [\"source\", \"click-log-parser\", \"repeat-visit\", \"reduce-operation\", \"sink\"],\n            selectivities: [],\n            // TODO\n            hasWindows: true,\n            hasThreshold: false,\n            query_plan: `SELECT url, COUNT(*) AS total_visits, \n            COUNT(DISTINCT user_id) AS unique_visits  //PARALLELIZATION -- **\nFROM ClickLogs //PARALLELIZATION -- *\nGROUP BY url; //PARALLELIZATION -- ***\n`\n          }, {\n            id: 2,\n            name: '2. visits based on location',\n            operators: [\"source\", \"click-log-parser\", \"geography-visit\", \"sink\"],\n            selectivities: [],\n            // TODO\n            hasWindows: true,\n            hasThreshold: false,\n            query_plan: `SELECT \n  location.country,\n  COUNT(*) AS visits,\n  location.city,\n  COUNT(*) AS city_visits\nFROM ClickLogs //PARALLELIZATION -- *\nJOIN (\n  SELECT   //PARALLELIZATION -- **\n    ip_address,\n    MAX(city) AS city,\n    MAX(country) AS country\n  FROM GeoIPDatabase\n  GROUP BY ip_address\n) AS location ON ClickLogs.ip_address = location.ip_address\nGROUP BY location.country, location.city;\n`\n          }, {\n            id: 3,\n            name: '3. Unique and total visits (countbased window)',\n            operators: [\"source\", \"click-log-parser\", \"repeat-visit\", \"reduce-operation\", \"sink\"],\n            selectivities: [],\n            // TODO\n            hasWindows: true,\n            hasThreshold: false,\n            query_plan: `SELECT url, COUNT(*) AS total_visits, \n            COUNT(DISTINCT user_id) AS unique_visits  //PARALLELIZATION -- **\nFROM ClickLogs //PARALLELIZATION -- *\nGROUP BY url; //PARALLELIZATION -- ***\n`\n          }]\n        },\n        'Linear Road': {\n          query_list: [{\n            id: 1,\n            name: '1. Toll Notification',\n            operators: [\"source\", \"Vehicle-event-parser\", \"toll-notification\", \"formatter-toll-notification\", \"sink\"],\n            selectivities: [],\n            // TODO\n            hasWindows: false,\n            hasThreshold: false,\n            query_plan: `SELECT\n    v.vehicleId,\n    COALESCE(SUM(t.tollAmount), 0) AS totalToll\nFROM\n    Vehicles v //PARALLELIZATION -- *\nLEFT JOIN\n    (\n        SELECT  //PARALLELIZATION -- **\n            vehicleId,\n            segmentId,\n            calculateToll(averageSpeed, numVehicles) AS tollAmount\n        FROM\n            (\n                SELECT //PARALLELIZATION -- ***\n                    segmentId,\n                    vehicleId,\n                    AVG(speed) AS averageSpeed,\n                    COUNT(*) AS numVehicles\n                FROM\n                    VehicleSpeedData\n                GROUP BY\n                    segmentId, vehicleId\n            ) subquery\n    ) t\nON\n    v.vehicleId = t.vehicleId\nGROUP BY\n    v.vehicleId\n\n`\n          }, {\n            id: 2,\n            name: '2. Accident Notification',\n            operators: [\"source\", \"Vehicle-event-parser\", \"accident-notification\", \"formatter-accident-notification\", \"sink\"],\n            selectivities: [],\n            // TODO\n            hasWindows: true,\n            hasThreshold: false,\n            query_plan: `SELECT //PARALLELIZATION -- ***\n    eventTime,\n    CASE\n        WHEN COUNT(*) >= 3 THEN 'Accident Detected' //PARALLELIZATION -- **\n        ELSE 'No Accident'\n    END AS accidentStatus\nFROM\n    VehicleEvents //PARALLELIZATION -- *\nGROUP BY\n    SlidingWindow(eventTime, 5 minutes, 30 seconds)\n\n`\n          }, {\n            id: 3,\n            name: '3. Daily Expenditure',\n            operators: [\"source\", \"Vehicle-event-parser\", \"daily-expenditure\", \"sink\"],\n            selectivities: [],\n            // TODO\n            hasWindows: false,\n            hasThreshold: false,\n            query_plan: `SELECT  //PARALLELIZATION -- **\n    vehicleId,\n    DATE(eventTime) AS expenditureDate,\n    SUM(expenditureAmount) AS dailyExpenditure\nFROM\n    VehicleEvents  //PARALLELIZATION -- *\nGROUP BY\n    vehicleId, DATE(eventTime)\n\n`\n          }, {\n            id: 4,\n            name: '4. visits based on location',\n            operators: [\"source\", \"Vehicle-event-parser\", \"vehicle-report-mapper\", \"sink\"],\n            selectivities: [],\n            // TODO\n            hasWindows: false,\n            hasThreshold: false,\n            query_plan: `SELECT  //PARALLELIZATION -- **\n    vehicleId,\n    COUNT(*) AS totalReports\nFROM\n    VehicleEvents   //PARALLELIZATION -- *\nGROUP BY\n    vehicleId\n\n`\n          }]\n        },\n        'TPCH': {\n          query_list: [{\n            id: 1,\n            name: '1. Priority Order Counter (no window)',\n            operators: [\"source\", \"tpch-event-parser\", \"tpch-data-filter\", \"tpch-flat-mapper\", \"priority-counter\", \"sink\"],\n            selectivities: [],\n            // TODO\n            hasWindows: false,\n            hasThreshold: false,\n            query_plan: ``\n          }, {\n            id: 2,\n            name: '1. Priority Order Counter (window)',\n            operators: [\"source\", \"tpch-event-parser\", \"tpch-data-filter\", \"tpch-flat-mapper\", \"priority-counter\", \"sink\"],\n            selectivities: [],\n            // TODO\n            hasWindows: true,\n            hasThreshold: false,\n            query_plan: `-- Filter and count orders with priorities between \"1-URGENT\" and \"5-LOW\"\nSELECT\n    o_orderpriority,\n    COUNT(*) AS orderCount  //PARALLELIZATION -- ***\nFROM\n    TPCHEvents //PARALLELIZATION -- *\nWHERE\n    o_orderpriority >= '1-URGENT' AND o_orderpriority <= '5-LOW' //PARALLELIZATION -- **\nGROUP BY\n    o_orderpriority\n\n`\n          }]\n        },\n        'Machine Outlier': {\n          query_list: [{\n            id: 1,\n            name: '1. Machine Outlier Detection',\n            operators: [\"source\", \"machine-usage-parser\", \"machine-usage-grouper\", \"outlier-detector\", \"sink\"],\n            selectivities: [],\n            // TODO\n            hasWindows: true,\n            hasThreshold: true,\n            query_plan: `\nSELECT\n    MachineId,\n    Timestamp,\n    UsageValue\nFROM\n    MachineUsageData  //PARALLELIZATION -- *\nWHERE  \n    Timestamp >= (CurrentTimestamp - SlidingWindowSize) //PARALLELIZATION -- **\n    AND Timestamp <= CurrentTimestamp \nGROUP BY\n    MachineId, Timestamp\nHAVING    \n    COUNT(*) = 1    //PARALLELIZATION -- ***\n\n`\n          }]\n        },\n        'Traffic Monitoring': {\n          query_list: [{\n            id: 1,\n            name: '1. Traffic Monitor',\n            operators: [\"source\", \"traffic-event-parser\", \"road-matcher\", \"avg-speed\", \"formatter\", \"sink\"],\n            selectivities: [],\n            // TODO\n            hasWindows: true,\n            hasThreshold: false,\n            query_plan: `\n\n-- Step 1: Parse Traffic Events\nSELECT        //PARALLELIZATION -- *\n    TrafficEventId,\n    Timestamp,\n    VehicleId,\n    RoadId,\n    Speed\nFROM\n    TrafficEvents;\n\n-- Step 2: Road Matching\nWITH RoadMatch AS (         //PARALLELIZATION -- **\n    SELECT\n        TrafficEventId,\n        Timestamp,\n        VehicleId,\n        RoadId\n    FROM\n        ParsedTrafficEvents\n    WHERE\n        RoadId IS NOT NULL\n),\n\n-- Step 3: Calculate Average Speed\nAvgSpeed AS (           //PARALLELIZATION -- ***\n    SELECT\n        RoadId,\n        AVG(Speed) AS AverageSpeed\n    FROM\n        RoadMatch\n    GROUP BY\n        RoadId\n),\n\n-- Step 4: Format Results\nFormattedResults AS (         //PARALLELIZATION -- ****\n    SELECT\n        RoadId,\n        AverageSpeed\n    FROM\n        AvgSpeed\n    WHERE\n        AverageSpeed > 0\n)\n\n-- Step 5: Output Results (Sink)\nINSERT INTO\n    TrafficResults\nSELECT\n    RoadId,\n    AverageSpeed\nFROM\n    FormattedResults;\n\n`\n          }]\n        }\n      },\n      job_input: ['File', 'Kafka'],\n      f_job_class_name: '',\n      f_job_enumeration_strategy: 'None',\n      f_job_iteration_strategy: 'From Top',\n      f_job_custom_strategy: \"10,10,10,40\\n20,20,20,40\\n30,30,30,40\\n40,40,40,40\",\n      f_job_num_operators: \"0\",\n      f_job_query_name: '',\n      f_job_class_input_type: '',\n      f_job_class_input: '',\n      f_job_class_input_min: 100000,\n      f_job_class_input_max: 1000000,\n      f_parallelization_degree: [],\n      f_parallelization_degree_min: [],\n      f_parallelization_degree_max: [],\n      f_parallelization_degree_steps: [],\n      f_selectivities: [],\n      f_job_window_size: 100,\n      f_job_window_size_min: 10,\n      f_job_window_size_max: 1000,\n      f_job_window_slide_size: 10,\n      f_job_window_slide_size_min: 5,\n      f_job_window_slide_size_max: 20,\n      f_job_google_lateness: 0,\n      f_job_run_time: 6,\n      f_job_threshold: 5,\n      f_num_of_times_job_run: 1,\n      f_job_iterations: 100,\n      show_progress: false\n    };\n  },\n  // \n  // \n  methods: {\n    async createJob() {\n      this.showProgress = true;\n      var num = this.job_queries[this.f_job_class_name].query_list[this.f_job_query_name - 1].operators.length;\n      if (this.f_parallelization_degree.length != num) {\n        this.f_parallelization_degree = Array.from('0'.repeat(num));\n      }\n      if (this.f_parallelization_degree_steps.length != num) {\n        this.f_parallelization_degree_steps = Array.from('1'.repeat(num));\n      }\n      var data = {\n        \"job_class\": this.f_job_class_name,\n        //'Ad Analytics'\n        \"job_enumeration_strategy\": this.f_job_enumeration_strategy,\n        \"job_class_input_type\": this.f_job_class_input_type,\n        //'Kafka'\n        \"job_class_input\": this.f_job_class_input,\n        //kafka event rate\n        \"job_class_input_min\": this.f_job_class_input_min,\n        \"job_class_input_max\": this.f_job_class_input_max,\n        \"job_query_name\": this.f_job_query_name,\n        //'1'\n        \"job_pds\": this.f_parallelization_degree,\n        //[1,3,5,1,3]\n        \"job_pds_min\": this.f_parallelization_degree_min,\n        //[1,3,5,1,3]\n        \"job_pds_max\": this.f_parallelization_degree_max,\n        //[1,3,5,1,3]\n        \"job_pds_steps\": this.f_parallelization_degree_steps,\n        //[1,1,1,1,1]\n        \"job_selectivities\": this.f_selectivities,\n        //[1,3,5,1,3]\n        \"job_window_size\": this.f_job_window_size,\n        \"job_window_size_min\": this.f_job_window_size_min,\n        \"job_window_size_max\": this.f_job_window_size_max,\n        \"job_window_slide_size\": this.f_job_window_slide_size,\n        \"job_window_slide_size_min\": this.f_job_window_slide_size_min,\n        \"job_window_slide_size_max\": this.f_job_window_slide_size_max,\n        \"job_run_time\": this.f_job_run_time,\n        \"job_google_lateness\": this.f_job_google_lateness,\n        \"job_threshold\": this.f_job_threshold,\n        \"num_of_times_job_run\": this.f_num_of_times_job_run,\n        \"job_iterations\": this.f_job_iterations,\n        \"job_iteration_strategy\": this.f_job_iteration_strategy,\n        \"job_custom_strategy\": this.f_job_custom_strategy\n      };\n      console.log('providing job with these parameters');\n      console.log(data);\n      var endpoint = this.url + \":8000/infra/jobcreate/\" + this.cluster_id;\n      axios.post(endpoint, data).then(resp => {\n        this.showProgress = false;\n        console.log(resp.data);\n      }).catch(err => {\n        console.log(err);\n      });\n    },\n    async startCluster() {\n      await axios.get(this.url + \":8000/infra/start/\" + this.id).then(resp => {\n        this.snackbar = {\n          view: true,\n          timeout: 3000,\n          text: 'Started the cluster successfully',\n          color: 'primary'\n        };\n        console.log(resp);\n        this.refresh(this.id);\n        this.$emit('refresh', 'refreshed');\n      });\n    },\n    async stopCluster() {\n      await axios.get(this.url + \":8000/infra/stop/\" + this.id).then(resp => {\n        console.log(resp);\n        this.refresh(this.id);\n        this.snackbar = {\n          view: true,\n          timeout: 3000,\n          text: 'Stopped the cluster successfully',\n          color: 'primary'\n        };\n        this.$emit('refresh', 'refreshed');\n      });\n    },\n    async refresh(cluster_identifier) {\n      await axios.get(this.url + \":8000/infra/getCluster/\" + cluster_identifier).then(resp => {\n        this.cluster_id = resp.data.id;\n        this.cluster_name = resp.data.name;\n        this.cluster_status = resp.data.status;\n        console.log(resp);\n      });\n    },\n    async changeEnumStrategy() {\n      var base = 5;\n      var num = this.job_queries[this.f_job_class_name].query_list[this.f_job_query_name - 1].operators.length;\n      this.f_job_num_operators = num;\n      this.f_job_custom_strategy = \"\";\n      for (let i = 0; i < 8; i++) {\n        // generate pds\n        var pds = \"\";\n        for (let j = 0; j < num; j++) {\n          if (j != 0) {\n            pds += \",\";\n          }\n          pds += base * (i + 1);\n          console.log(pds);\n        }\n\n        // add pds as new line\n        if (i != 0) {\n          this.f_job_custom_strategy += \"\\n\";\n        }\n        this.f_job_custom_strategy += pds;\n      }\n    },\n    async changeQuery() {\n      this.f_selectivities = this.job_queries[this.f_job_class_name].query_list[this.f_job_query_name - 1].selectivities;\n      console.log(this.f_selectivities);\n      this.changeEnumStrategy();\n    }\n  },\n  computed: {\n    snackbar: {\n      get() {\n        return this.$store.state.snackbar;\n      },\n      set(value) {\n        this.$store.commit('setSnackbar', value);\n      }\n    },\n    getSelectedQueryPlan() {\n      const queryIndex = this.f_job_query_name - 1;\n      let queryPlan = this.job_queries[this.f_job_class_name].query_list[queryIndex].query_plan;\n      console.log('reached main');\n      if (this.f_job_class_name == 'Smart Grid' && (this.f_job_query_name == 1 || this.f_job_query_name == 2)) {\n        console.log('reacheed inside smart grid');\n        let newQuery = '//PARALLELIZATION --' + this.f_parallelization_degree[0];\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery);\n        console.log(queryPlan);\n      } else if (this.f_job_class_name == 'Ad Analytics' && this.f_job_query_name == 1) {\n        let newQuery1 = '//PARALLELIZATION --' + this.f_parallelization_degree[0];\n        let newQuery2 = '//PARALLELIZATION --' + this.f_parallelization_degree[1];\n        let newQuery3 = '//PARALLELIZATION --' + this.f_parallelization_degree[2];\n        let newQuery4 = '//PARALLELIZATION --' + this.f_parallelization_degree[3];\n        let newQuery5 = '//PARALLELIZATION --' + this.f_parallelization_degree[4];\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- ***', newQuery3);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- ****', newQuery4);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- *****', newQuery5);\n      } else if (this.f_job_class_name == 'Google cloud Monitoring' && (this.f_job_query_name == 1 || this.f_job_query_name == 2)) {\n        let newQuery1 = '//PARALLELIZATION --' + this.f_parallelization_degree[0];\n        let newQuery2 = '//PARALLELIZATION --' + this.f_parallelization_degree[1];\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2);\n      } else if (this.f_job_class_name == 'Sentiment Analysis' && this.f_job_query_name == 1) {\n        let newQuery1 = '//PARALLELIZATION --' + this.f_parallelization_degree[0];\n        let newQuery2 = '//PARALLELIZATION --' + this.f_parallelization_degree[1];\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2);\n      } else if (this.f_job_class_name == 'Spike Detection' && this.f_job_query_name == 1) {\n        let newQuery1 = '//PARALLELIZATION --' + this.f_parallelization_degree[0];\n        let newQuery2 = '//PARALLELIZATION --' + this.f_parallelization_degree[1];\n        let newQuery3 = '//PARALLELIZATION --' + this.f_parallelization_degree[2];\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- ***', newQuery3);\n      } else if (this.f_job_class_name == 'Log Processing' && (this.f_job_query_name == 1 || this.f_job_query_name == 2)) {\n        let newQuery1 = '//PARALLELIZATION --' + this.f_parallelization_degree[0];\n        let newQuery2 = '//PARALLELIZATION --' + this.f_parallelization_degree[1];\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2);\n      } else if (this.f_job_class_name == 'Trending Topics' && this.f_job_query_name == 1) {\n        let newQuery1 = '//PARALLELIZATION --' + this.f_parallelization_degree[0];\n        let newQuery2 = '//PARALLELIZATION --' + this.f_parallelization_degree[1];\n        let newQuery3 = '//PARALLELIZATION --' + this.f_parallelization_degree[2];\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- ***', newQuery3);\n      } else if (this.f_job_class_name == 'Bargain Index' && this.f_job_query_name == 1) {\n        let newQuery1 = '//PARALLELIZATION --' + this.f_parallelization_degree[0];\n        let newQuery2 = '//PARALLELIZATION --' + this.f_parallelization_degree[1];\n        let newQuery3 = '//PARALLELIZATION --' + this.f_parallelization_degree[2];\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- ***', newQuery3);\n      } else if (this.f_job_class_name == 'Click Analytics' && this.f_job_query_name == 1) {\n        let newQuery1 = '//PARALLELIZATION --' + this.f_parallelization_degree[0];\n        let newQuery2 = '//PARALLELIZATION --' + this.f_parallelization_degree[1];\n        let newQuery3 = '//PARALLELIZATION --' + this.f_parallelization_degree[2];\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- ***', newQuery3);\n      } else if (this.f_job_class_name == 'Click Analytics' && this.f_job_query_name == 2) {\n        let newQuery1 = '//PARALLELIZATION --' + this.f_parallelization_degree[0];\n        let newQuery2 = '//PARALLELIZATION --' + this.f_parallelization_degree[1];\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2);\n      } else if (this.f_job_class_name == 'Linear Road' && this.f_job_query_name == 1) {\n        let newQuery1 = '//PARALLELIZATION --' + this.f_parallelization_degree[0];\n        let newQuery2 = '//PARALLELIZATION --' + this.f_parallelization_degree[1];\n        let newQuery3 = '//PARALLELIZATION --' + this.f_parallelization_degree[2];\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- ***', newQuery3);\n      } else if (this.f_job_class_name == 'Linear Road' && this.f_job_query_name == 2) {\n        let newQuery1 = '//PARALLELIZATION --' + this.f_parallelization_degree[0];\n        let newQuery2 = '//PARALLELIZATION --' + this.f_parallelization_degree[1];\n        let newQuery3 = '//PARALLELIZATION --' + this.f_parallelization_degree[2];\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- ***', newQuery3);\n      } else if (this.f_job_class_name == 'Linear Road' && (this.f_job_query_name == 3 || this.f_job_query_name == 4)) {\n        let newQuery1 = '//PARALLELIZATION --' + this.f_parallelization_degree[0];\n        let newQuery2 = '//PARALLELIZATION --' + this.f_parallelization_degree[1];\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2);\n      } else if (this.f_job_class_name == 'TPCH' && this.f_job_query_name == 1) {\n        let newQuery1 = '//PARALLELIZATION --' + this.f_parallelization_degree[0];\n        let newQuery2 = '//PARALLELIZATION --' + this.f_parallelization_degree[1];\n        let newQuery3 = '//PARALLELIZATION --' + this.f_parallelization_degree[2];\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- ***', newQuery3);\n      } else if (this.f_job_class_name == 'Machine Outlier' && this.f_job_query_name == 1) {\n        let newQuery1 = '//PARALLELIZATION --' + this.f_parallelization_degree[0];\n        let newQuery2 = '//PARALLELIZATION --' + this.f_parallelization_degree[1];\n        let newQuery3 = '//PARALLELIZATION --' + this.f_parallelization_degree[2];\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- ***', newQuery3);\n      } else if (this.f_job_class_name == 'Traffic Monitoring' && this.f_job_query_name == 1) {\n        let newQuery1 = '//PARALLELIZATION --' + this.f_parallelization_degree[0];\n        let newQuery2 = '//PARALLELIZATION --' + this.f_parallelization_degree[1];\n        let newQuery3 = '//PARALLELIZATION --' + this.f_parallelization_degree[2];\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2);\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- ***', newQuery3);\n      }\n      return queryPlan;\n    },\n    getSelectedQueryList() {\n      return this.job_queries[this.f_job_class_name].query_list;\n    }\n  },\n  async mounted() {\n    this.refresh(this.id);\n  },\n  watch: {\n    id(new_val, old_val) {\n      if (new_val != old_val) this.refresh(this.id);\n    }\n  }\n};","map":{"version":3,"mappings":"AAuVA;AACA;AAGA;EAEAA;EACAC;IACAC;EACA;EACAC;IACAC;EACA;EACAC;IACA;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MAEAC;QACA;UACAC;YACAZ;YACAJ;YACAiB;YACAC;YACAC;UACA;QAEA;QACA;UACAH;YACAZ;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;UACA;YACAf;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;UACA;QAGA;QACA;UACAH;YACAZ;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;UACA;YACAf;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAD;UACA;QACA;QACA;UACAH;YACAZ;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAC;YACAF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;UACA;YACAf;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAC;YACAF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;UACA;QAGA;QACA;UACAH;YACAZ;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;UACA;QAGA;QACA;UACAH;YACAZ;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAC;YACAF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;UACA;QAIA;QACA;UACAH;YACAZ;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;UACA;YACAf;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;UACA;QAGA;QACA;UACAH;YACAZ;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAE;YACAH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;UACA;QAGA;QACA;UACAH;YACAZ;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAE;YACAH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;UACA;QAGA;QACA;UACAH;YACAZ;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAE;YACAH;AACA;AACA;AACA;AACA;UACA;YACAf;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAE;YACAH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;UACA;YACAf;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAE;YACAH;AACA;AACA;AACA;AACA;UACA;QAEA;QACA;UACAH;YACAZ;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAE;YACAH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;UACA;YACAf;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAE;YACAH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;UACA;YACAf;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAE;YACAH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;UACA;YACAf;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAE;YACAH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;UACA;QAGA;QACA;UACAH;YACAZ;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAE;YACAH;UACA;YACAf;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAE;YACAH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;UACA;QAGA;QACA;UACAH;YACAZ;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAE;YACAH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;UACA;QAGA;QACA;UACAH;YACAZ;YACAJ;YACAiB;YACAC;YAAA;YACAE;YACAE;YACAH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;UACA;QAGA;MACA;MACAI;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;IAGA;EACA;EACA;EACA;EACAC;IACA;MACA;MACA;MACA;QACA;MACA;MACA;QACA;MACA;MACA;QACA;QAAA;QACA;QACA;QAAA;QACA;QAAA;QACA;QACA;QACA;QAAA;QACA;QAAA;QACA;QAAA;QACA;QAAA;QACA;QAAA;QACA;QAAA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;MACA;MACAC;MACAA;MAEA;MAEAC,MACAC,qBACAC;QACA;QACAH;MACA,GACAI;QACAJ;MACA;IACA;IACA;MACA,YACAK,+CACAF;QACA;UACAG;UACAC;UACAC;UACAC;QACA;QACAT;QACA;QACA;MACA;IACA;IACA;MACA,YACAK,8CACAF;QAEAH;QACA;QACA;UACAM;UACAC;UACAC;UACAC;QACA;QACA;MACA;IACA;IACA;MACA,YACAJ,+DACAF;QACA;QACA;QACA;QACAH;MACA;IACA;IACA;MACA;MACA;MACA;MACA;MACA;QACA;QACA;QACA;UACA;YACAU;UACA;UACAA;UACAV;QACA;;QAEA;QACA;UACA;QACA;QACA;MACA;IACA;IACA;MACA;MACAA;MACA;IACA;EAEA;EACAW;IACAC;MACAP;QACA;MACA;MACAQ;QACA;MACA;IACA;IACAC;MAEA;MACA;MACAd;MACA;QACAA;QAEA;QACAe;QACAf;MAEA;QAGA;QACA;QACA;QACA;QACA;QAEAe;QACAA;QACAA;QACAA;QACAA;MAEA;QAGA;QACA;QAGAA;QACAA;MAGA;QAGA;QACA;QAGAA;QACAA;MAGA;QAGA;QACA;QACA;QAEAA;QACAA;QACAA;MAGA;QAGA;QACA;QAGAA;QACAA;MAIA;QAGA;QACA;QACA;QAEAA;QACAA;QACAA;MAGA;QAGA;QACA;QACA;QAEAA;QACAA;QACAA;MAGA;QAGA;QACA;QACA;QAEAA;QACAA;QACAA;MAEA;QAEA;QACA;QACAA;QACAA;MACA;QAGA;QACA;QACA;QAEAA;QACAA;QACAA;MAGA;QAGA;QACA;QACA;QAEAA;QACAA;QACAA;MAGA;QAEA;QACA;QAEAA;QACAA;MAEA;QAGA;QACA;QACA;QAEAA;QACAA;QACAA;MAGA;QAGA;QACA;QACA;QAEAA;QACAA;QACAA;MAGA;QAGA;QACA;QACA;QAEAA;QACAA;QACAA;MAGA;MACA;IACA;IACAC;MAGA;IACA;EACA;EACA;IAEA;EAGA;EACAC;IACAjE;MACA,wBACA;IACA;EACA;AACA","names":["name","components","CodeEditor","props","id","data","showProgress","joblogs","url","cluster_name","cluster_id","cluster_status","enumeration_strategies","iteration_strategies","job_class","job_queries","query_list","operators","selectivities","query_plan","hasWindows","hasLateness","hasThreshold","job_input","f_job_class_name","f_job_enumeration_strategy","f_job_iteration_strategy","f_job_custom_strategy","f_job_num_operators","f_job_query_name","f_job_class_input_type","f_job_class_input","f_job_class_input_min","f_job_class_input_max","f_parallelization_degree","f_parallelization_degree_min","f_parallelization_degree_max","f_parallelization_degree_steps","f_selectivities","f_job_window_size","f_job_window_size_min","f_job_window_size_max","f_job_window_slide_size","f_job_window_slide_size_min","f_job_window_slide_size_max","f_job_google_lateness","f_job_run_time","f_job_threshold","f_num_of_times_job_run","f_job_iterations","show_progress","methods","console","axios","post","then","catch","get","view","timeout","text","color","pds","computed","snackbar","set","getSelectedQueryPlan","queryPlan","getSelectedQueryList","watch"],"sourceRoot":"src/components","sources":["ClusterInfo.vue"],"sourcesContent":["<template>\n  <div>\n    <v-card>\n      <v-toolbar flat color=\"primary\" dark>\n        <v-toolbar-title>Cluster Info: {{ cluster_name }}</v-toolbar-title>\n      </v-toolbar>\n      <v-tabs>\n        <v-tab>\n          <v-icon left>\n            mdi-account\n          </v-icon>\n          Cluster Admin\n        </v-tab>\n        <v-tab>\n          <v-icon left>\n            mdi-lock\n          </v-icon>\n          Cluster Logs\n        </v-tab>\n        <v-tab>\n          <v-icon left>\n            mdi-access-point\n          </v-icon>\n          Provide Jobs\n        </v-tab>\n\n\n        <v-tab-item>\n          <v-card flat class=\"mx-16 mb-6\">\n            <v-card-subtitle>Cluster Configuration:</v-card-subtitle>\n            <v-card-text>\n              <v-row>\n                <v-col cols=\"3\">\n                  <v-list dense>\n                    <v-list-item>\n                      <v-list-item-title></v-list-item-title>\n                      <v-list-item-subtitle></v-list-item-subtitle>\n                    </v-list-item>\n                  </v-list>\n                </v-col>\n              </v-row>\n\n\n            </v-card-text>\n            <v-card-actions>\n              <v-spacer></v-spacer>\n              <v-btn v-if=\"cluster_status == 'Stopped'\" @click=\"startCluster()\" color=\"primary\">Start Cluster</v-btn>\n              <v-btn v-if=\"cluster_status == 'Running'\" @click=\"stopCluster()\" color=\"error\">Stop Cluster</v-btn>\n            </v-card-actions>\n          </v-card>\n        </v-tab-item>\n        <v-tab-item>\n          <v-card flat>\n            <v-card-subtitle>Flink Logs</v-card-subtitle>\n            <v-card-text>\n              <v-card dark max-height=\"100%\">\n                {{ joblogs }}\n\n              </v-card>\n            </v-card-text>\n          </v-card>\n        </v-tab-item>\n        <v-tab-item>\n          <v-card flat>\n            <v-card-text>\n              <v-row>\n                <!-- job class -->\n                <v-col cols=\"12\">\n                  <v-select v-model=\"f_job_class_name\" :items=\"job_class\" v-on:change=\"changeQuery\"\n                    label=\"Please select a job class\" outlined>\n                  </v-select>\n                </v-col>\n\n                <!-- enumeration strategy -->\n                <v-col cols=\"12\">\n                  <v-select v-model=\"f_job_enumeration_strategy\" :items=\"enumeration_strategies\"\n                    label=\"Enumeration strategy\" v-on:change=\"changeEnumStrategy\" outlined>\n                  </v-select>\n                </v-col>\n\n                <!-- iterations -->\n                <v-col cols=\"12\" v-if=\"f_job_enumeration_strategy != 'None' && f_job_enumeration_strategy != 'Custom'\">\n                  <v-row class=\"align-self-center\">\n                    <v-col cols=\"12\" sm=\"6\">\n                      <v-text-field v-model=\"f_job_iterations\"\n                        label=\"Iteration (Number of different parallelism settings)\" outlined type=\"number\">\n                      </v-text-field>\n                    </v-col>\n                    <v-col cols=\"12\" sm=\"6\">\n                      <v-select v-model=\"f_job_iteration_strategy\" :items=\"iteration_strategies\" item-text=\"name\"\n                        item-value=\"id\" label=\"Iteration Strategy\" outlined>\n                      </v-select>\n                    </v-col>\n                  </v-row>\n                </v-col>\n\n                <!-- custom enumeration settings -->\n                <v-col cols=\"12\" v-if=\"f_job_enumeration_strategy == 'Custom'\">\n                  <v-template v-if=\"f_job_num_operators == 0\"><b>Please select a query first</b></v-template>\n                  <v-template v-if=\"f_job_num_operators != 0\">\n                    {{ f_job_class_name }} (Query {{ f_job_query_name }}) has <b>{{ f_job_num_operators }} Operators</b>\n                  </v-template>\n                  <v-textarea v-model=\"f_job_custom_strategy\" variant=\"outlined\"\n                      label=\"Custom Enumeration Settings\" auto-grow\n                      value=\"\">\n                  </v-textarea>\n                </v-col>\n\n                <!-- samples -->\n                <v-col cols=\"12\" v-if=\"f_job_enumeration_strategy != 'Custom'\">\n                  <v-text-field v-if=\"f_job_enumeration_strategy == 'None'\" v-model=\"f_num_of_times_job_run\"\n                    label=\"Number of times job has to run\" outlined type=\"number\">\n                  </v-text-field>\n                  <v-text-field v-if=\"f_job_enumeration_strategy != 'None'\" v-model=\"f_num_of_times_job_run\"\n                    label=\"Samples (Run per parallelism settings)\" outlined type=\"number\">\n                  </v-text-field>\n                </v-col>\n\n                <!-- class name -->\n                <v-col cols=\"12\" v-if=\"f_job_class_name != ''\">\n                  <v-select v-model=\"f_job_query_name\" :items=\"getSelectedQueryList\" v-on:change=\"changeQuery\"\n                    item-text=\"name\" item-value=\"id\" label=\"Please select a query\" outlined>\n                  </v-select>\n                </v-col>\n\n               <!--  <v-col>\n                  <h1>Flowchart</h1>\n                  <flow-chart></flow-chart>\n                </v-col> -->\n\n\n                <!-- input -->\n                <v-col cols=\"12\" v-if=\"f_job_query_name != ''\">\n                  <v-select v-model=\"f_job_class_input_type\" :items=\"job_input\" label=\"Please select the input for query\"\n                    outlined>\n                  </v-select>\n                </v-col>\n                <v-col cols=\"12\" v-if=\"f_job_class_input_type == 'File'\">\n                  <v-file-input v-model=\"f_job_class_input\" label=\"File input\" outlined dense>\n                  </v-file-input>\n                </v-col>\n                <v-col cols=\"12\" v-if=\"f_job_class_input_type == 'Kafka' && (f_job_enumeration_strategy == 'None' || f_job_enumeration_strategy == 'Rulebased')\">\n                  <v-text-field v-model=\"f_job_class_input\" label=\"Kafka event rate\" outlined type=\"number\">\n                  </v-text-field>\n                </v-col>\n                <v-col cols=\"12\" v-if=\"f_job_class_input_type == 'Kafka' && f_job_enumeration_strategy != 'None' && f_job_enumeration_strategy != 'Rulebased'\">\n                    <v-row class=\"align-self-center\">\n                        <v-col cols=\"12\" sm=\"6\">\n                            <v-text-field v-model=\"f_job_class_input_min\" label=\"Minimum Kafka event rate\" outlined type=\"number\">\n                            </v-text-field>\n                        </v-col>\n                        <v-col cols=\"12\" sm=\"6\">\n                            <v-text-field v-model=\"f_job_class_input_max\" label=\"Maximum Kafka event rate\" outlined type=\"number\">\n                            </v-text-field>\n                        </v-col>\n                    </v-row>\n                </v-col>\n\n                <!-- parallelism degree -->\n                <v-col cols=\"12\" v-if=\"f_job_enumeration_strategy == 'None' && f_job_class_input_type != ''\">\n                    <v-text-field\n                        v-for=\"(operator, index) in job_queries[f_job_class_name].query_list[f_job_query_name - 1].operators\"\n                        :key=\"operator\" v-model=\"f_parallelization_degree[index]\" :label=\"operator + ' parallelization degree'\"\n                        outlined type=\"number\">\n                    </v-text-field>\n                </v-col>\n                <v-col cols=\"12\" v-if=\"f_job_enumeration_strategy == 'Random' && f_job_class_input_type != ''\">\n                    <v-row class=\"align-self-center\" v-for=\"(operator, index) in job_queries[f_job_class_name].query_list[f_job_query_name - 1].operators\" :key=\"operator\">\n                        <v-col cols=\"12\" sm=\"8\">\n                          <v-text-field v-model=\"f_parallelization_degree[index]\" :label=\"operator + ' parallelization degree'\"\n                            outlined type=\"number\" disabled hint=\"Set through enumeration strategy\" persistent-hint>\n                          </v-text-field>\n                        </v-col>\n                        <v-col cols=\"12\" sm=\"4\">\n                            <v-text-field v-model=\"f_parallelization_degree_steps[index]\"\n                                :label=\"'Step Size'\" outlined type=\"number\" disabled></v-text-field>\n                        </v-col>\n                    </v-row>\n                </v-col>\n                <v-col cols=\"12\" v-if=\"f_job_enumeration_strategy == 'Exhaustive' && f_job_class_input_type != ''\">\n                    <v-row class=\"align-self-center\" v-for=\"(operator, index) in job_queries[f_job_class_name].query_list[f_job_query_name - 1].operators\" :key=\"operator\">\n                        <v-col cols=\"12\" sm=\"8\">\n                          <v-text-field v-model=\"f_parallelization_degree[index]\" :label=\"operator + ' parallelization degree'\"\n                            outlined type=\"number\" disabled hint=\"Set through enumeration strategy\" persistent-hint>\n                          </v-text-field>\n                        </v-col>\n                        <v-col cols=\"12\" sm=\"4\">\n                            <v-text-field v-model=\"f_parallelization_degree_steps[index]\"\n                                :label=\"'Step Size'\" outlined type=\"number\"></v-text-field>\n                        </v-col>\n                    </v-row>\n                </v-col>\n                <v-col cols=\"12\" v-if=\"f_job_enumeration_strategy == 'Rulebased' && f_job_class_input_type != ''\">\n                    <v-row class=\"align-self-center\" v-for=\"(operator, index) in job_queries[f_job_class_name].query_list[f_job_query_name - 1].operators\" :key=\"operator\">\n                        <v-col cols=\"12\" sm=\"4\">\n                            <v-text-field\n                                v-model=\"f_selectivities[index]\" :label=\"operator + ' selectivity'\" outlined type=\"number\">\n                            </v-text-field>\n                        </v-col>\n                        <v-col cols=\"12\" sm=\"4\">\n                            <v-text-field v-model=\"f_parallelization_degree_max[index]\"\n                                :label=\"'Distance'\" outlined type=\"number\"></v-text-field>\n                        </v-col>\n                        <v-col cols=\"12\" sm=\"4\">\n                            <v-text-field v-model=\"f_parallelization_degree_steps[index]\"\n                                :label=\"'Step Size'\" outlined type=\"number\"></v-text-field>\n                        </v-col>\n                    </v-row>\n                </v-col>\n                <v-col cols=\"12\" v-if=\"f_job_enumeration_strategy == 'MinMax' && f_job_class_input_type != ''\">\n                    <v-row class=\"align-self-center\" v-for=\"(operator, index) in job_queries[f_job_class_name].query_list[f_job_query_name - 1].operators\" :key=\"operator\">\n                        <v-col cols=\"12\" sm=\"4\">\n                            <v-text-field v-model=\"f_parallelization_degree_min[index]\"\n                                :label=\"'Minimum ' + operator + ' parallelization degree'\" outlined type=\"number\"></v-text-field>\n                        </v-col>\n                        <v-col cols=\"12\" sm=\"4\">\n                            <v-text-field v-model=\"f_parallelization_degree_max[index]\"\n                                :label=\"'Maximum ' + operator + ' parallelization degree'\" outlined type=\"number\"></v-text-field>\n                        </v-col>\n                        <v-col cols=\"12\" sm=\"4\">\n                            <v-text-field v-model=\"f_parallelization_degree_steps[index]\"\n                                :label=\"'Step Size'\" outlined type=\"number\"></v-text-field>\n                        </v-col>\n                    </v-row>\n                </v-col>\n\n                <!-- sql -->\n                <v-col cols=\"12\" v-if=\"f_job_query_name != ''\">\n                  <code-editor :query-plan=\"getSelectedQueryPlan\"></code-editor>\n                </v-col>\n\n                <!-- threshold -->\n                <v-col cols=\"12\"\n                  v-if=\"f_job_class_input != '' && job_queries[f_job_class_name].query_list[f_job_query_name - 1].hasThreshold\">\n                  <v-text-field v-model=\"f_job_threshold\" label=\"threshold\" outlined type=\"number\">\n\n                  </v-text-field>\n                </v-col>\n\n                <!-- window size -->\n                <v-col cols=\"12\"\n                  v-if=\"f_job_class_input_type != '' && job_queries[f_job_class_name].query_list[f_job_query_name - 1].hasWindows && f_job_enumeration_strategy == 'None'\">\n                  <v-text-field v-model=\"f_job_window_size\" label=\"Window Size\" outlined type=\"number\">\n                  </v-text-field>\n                </v-col>\n                <v-col cols=\"12\"\n                    v-if=\"f_job_class_input_type != '' && job_queries[f_job_class_name].query_list[f_job_query_name - 1].hasWindows && f_job_enumeration_strategy != 'None'\">\n                    <v-row class=\"align-self-center\">\n                        <v-col cols=\"12\" sm=\"6\">\n                            <v-text-field v-model=\"f_job_window_size_min\" label=\"Minimum Window Size\" outlined type=\"number\">\n                            </v-text-field>\n                        </v-col>\n                        <v-col cols=\"12\" sm=\"6\">\n                            <v-text-field v-model=\"f_job_window_size_max\" label=\"Maximum Window Size\" outlined type=\"number\">\n                            </v-text-field>\n                        </v-col>\n                    </v-row>\n                </v-col>\n\n                <!-- window slide size -->\n                <v-col cols=\"12\"\n                  v-if=\"f_job_class_input_type != '' && job_queries[f_job_class_name].query_list[f_job_query_name - 1].hasWindows && f_job_enumeration_strategy == 'None'\">\n                  <v-text-field v-model=\"f_job_window_slide_size\" label=\"Window Slide Size\" outlined type=\"number\">\n                  </v-text-field>\n                </v-col>\n                <v-col cols=\"12\"\n                    v-if=\"f_job_class_input_type != '' && job_queries[f_job_class_name].query_list[f_job_query_name - 1].hasWindows && f_job_enumeration_strategy != 'None'\">\n                    <v-row class=\"align-self-center\">\n                        <v-col cols=\"12\" sm=\"6\">\n                            <v-text-field v-model=\"f_job_window_slide_size_min\" label=\"Minimum Window Slide Size\" outlined type=\"number\">\n                            </v-text-field>\n                        </v-col>\n                        <v-col cols=\"12\" sm=\"6\">\n                            <v-text-field v-model=\"f_job_window_slide_size_max\" label=\"Maximum Window Slide Size\" outlined type=\"number\">\n                            </v-text-field>\n                        </v-col>\n                    </v-row>\n                </v-col>\n\n                <!-- watermark lateness -->\n                <v-col cols=\"12\"\n                  v-if=\"f_job_class_input_type != '' && job_queries[f_job_class_name].query_list[f_job_query_name - 1].hasLateness\">\n                  <v-text-field v-model=\"f_job_google_lateness\" label=\"Watermark Lateness\" outlined type=\"number\">\n\n                  </v-text-field>\n                </v-col>\n\n                <!-- run time -->\n                <v-col cols=\"12\">\n                  <v-text-field v-if=\"f_job_class_input_type != ''\" v-model=\"f_job_run_time\"\n                    label=\"How long each job should run in minutes\" outlined type=\"number\">\n                  </v-text-field>\n                </v-col>\n              </v-row>\n              <v-row>\n\n                <v-col cols=\"4\">\n                  <v-btn dark color=\"primary\" @click=\"createJob()\">\n                    Submit Job\n                  </v-btn>\n                </v-col>\n                <v-col cols=\"4\"></v-col>\n              </v-row>\n            </v-card-text>\n          </v-card>\n        </v-tab-item>\n      </v-tabs>\n    </v-card>\n    <v-dialog width=\"50%\" v-model=\"showProgress\">\n      <v-card dark>\n        <v-card-title>Please wait <v-progress-linear color=\"deep-purple green\" indeterminate rounded\n            height=\"6\"></v-progress-linear></v-card-title>\n        <v-card-text>\n          <v-list dense>\n            <v-list-item>\n              Starting Zookeeper\n            </v-list-item>\n            <v-list-item>\n              Starting Kafka\n            </v-list-item>\n            <v-list-item>\n              Creating topics\n            </v-list-item>\n            <v-list-item>\n              Sending Job\n            </v-list-item>\n            <v-list-item>\n              Starting producer\n            </v-list-item>\n\n\n\n\n\n\n          </v-list>\n        </v-card-text>\n\n      </v-card>\n    </v-dialog>\n  </div>\n</template>\n<script lang=\"js\">\nimport axios from 'axios';\nimport CodeEditor from './CodeEditor.vue';\n\n\nexport default {\n\n  name: 'ClusterInfo',\n  components: {\n    CodeEditor\n  },\n  props: {\n    id: String\n  },\n  data() {\n    return {\n      showProgress: false,\n      joblogs: 'Job logs ',\n      url: process.env.VUE_APP_URL,\n      cluster_name: '',\n      cluster_id: '',\n      cluster_status: '',\n      enumeration_strategies: ['None', 'Random', 'Rulebased', 'Exhaustive', 'MinMax', 'Custom'],\n      iteration_strategies: ['From Top', 'From Bottom', 'Random'],\n      job_class: ['Word Count', 'Smart Grid', 'Ad Analytics', 'Google cloud Monitoring', 'Sentiment Analysis', 'Spike Detection', 'Log Processing', 'Trending Topics', 'Bargain Index', 'Click Analytics', 'Machine Outlier', 'Linear Road', 'TPCH', 'Traffic Monitoring' ],\n\n      job_queries: {\n        'Word Count': {\n          query_list: [{\n            id: 1,\n            name: '1. Counting the number of words',\n            operators: ['Source', 'tokenizer', 'Counter', 'Sink'],\n            selectivities: [1, 6, 1, 1],\n            query_plan: 'SELECT count(*) FROM words'\n          }],\n\n        },\n        'Smart Grid': {\n          query_list: [{\n            id: 1,\n            name: '1. Calculate the global average load of each house',\n            operators: ['source','house-event-parser','global average load','sink'],\n            selectivities: [],  // TODO\n            hasWindows: true,\n            query_plan: `SELECT\n    HouseEvent.house,\n    AVG(HouseEvent.load) AS average_load,\n    TUMBLE_START(event_time, INTERVAL slidingWindowSize SECOND) AS window_start,\n    TUMBLE_END(event_time, INTERVAL slidingWindowSize SECOND) AS window_end\nFROM\n    HouseEvent\nGROUP BY  \n    HouseEvent.house,\n    TUMBLE(event_time, INTERVAL slidingWindowSize SECOND) //PARALLELIZATION -- *\n\n`\n          }, {\n            id: 2,\n            name: '2. Calculate the local average load of plugs in each household',\n            operators: ['source','house-event-parser','local average load','sink'],\n            selectivities: [],  // TODO\n            hasWindows: true,\n            query_plan: `SELECT\n    HouseEvent.house,\n    HouseEvent.households,\n    HouseEvent.plugs,\n    AVG(HouseEvent.load) AS average_load,\n    TUMBLE_START(event_time, INTERVAL slidingWindowSize SECOND) AS window_start,\n    TUMBLE_END(event_time, INTERVAL slidingWindowSize SECOND) AS window_end\nFROM\n    HouseEvent\nGROUP BY\n    HouseEvent.house,\n    HouseEvent.households,\n    HouseEvent.plugs,\n    TUMBLE(event_time, INTERVAL slidingWindowSize SECOND) //PARALLELIZATION -- *\n`\n          },\n          ]\n\n        },\n        'Ad Analytics': {\n          query_list: [{\n            id: 1,\n            name: '1. Calculate the Ad_analytics query (join)',\n            operators: [\"source\", \"click-parser\", \"impression-parser\", \"clicks-counter\", \"impressions-counter\", \"rollingCTR\", \"sink\"],\n            selectivities: [],  // TODO\n            hasWindows: true,\n            query_plan: `-- Step 1: Parse clicks and impressions\nWITH parsed_clicks AS (\n  SELECT query_id, ad_id, COUNT(*) AS click_count\n  FROM clicks\n  GROUP BY query_id, ad_id \n),  //PARALLELIZATION -- *\nparsed_impressions AS (\n  SELECT query_id, ad_id, COUNT(*) AS impression_count\n  FROM impressions\n  GROUP BY query_id, ad_id \n),//PARALLELIZATION -- **\n\n-- Step 2: Calculate CTR\nrolling_ctr AS (\n  SELECT\n    pc.query_id,\n    pc.ad_id,\n    pc.click_count,\n    pi.impression_count,\n    pc.click_count / pi.impression_count AS ctr\n  FROM parsed_clicks pc\n  JOIN parsed_impressions pi ON pc.query_id = pi.query_id AND pc.ad_id = pi.ad_id\n  WHERE pc.click_count <= pi.impression_count\n) //PARALLELIZATION -- ***\n\n-- Step 3: Output the result //PARALLELIZATION -- ****\nSELECT *\nFROM rolling_ctr; //PARALLELIZATION -- *****`\n          }, {\n            id: 2,\n            name: '1. Calculate the Ad_analytics query (no join)',\n            operators: [\"source\", \"parser\", \"counter\", \"rollingCTR\", \"sink\"],\n            selectivities: [],  // TODO\n            hasWindows: true,\n            query_plan: ``\n          }]\n        },\n        'Google cloud Monitoring': {\n          query_list: [{\n            id: 1,\n            name: '1. Calculate average-cpu-per-category',\n            operators: [\"source\", \"parser\", \"avg-cpu-per-category\", \"sink\"],\n            selectivities: [],  // TODO\n            hasWindows: true,\n            hasLateness: true,\n            query_plan: `SELECT  //PARALLELIZATION -- *\n    category,\n    AVG(cpu_usage) AS avg_cpu_usage\nFROM\n    Google_Cloud_Monitoring_stream\nWHERE\n    event_type = 1\nGROUP BY  //PARALLELIZATION -- **\n    category  \n`\n          }, {\n            id: 2,\n            name: '2. Calculate average-cpu-per-job',\n            operators: [\"source\", \"parser\", \"avg-cpu-per-job\", \"sink\"],\n            selectivities: [],  // TODO\n            hasWindows: true,\n            hasLateness: true,\n            query_plan: `SELECT //PARALLELIZATION -- *\n    job_id,\n    AVG(cpu_usage) AS avg_cpu_usage\nFROM\nGoogle_Cloud_Monitoring_stream\nWHERE\n    event_type = 1\nGROUP BY  //PARALLELIZATION -- **\n    job_id  `\n          },\n          ]\n\n        },\n        'Sentiment Analysis': {\n          query_list: [{\n            id: 1,\n            name: '1. Calculate sentiment analysis',\n            operators: [\"source\", \"twitter parser\", \"twitter analyser\", \"sink\"],\n            selectivities: [],  // TODO\n            hasWindows: false,\n            query_plan: `SELECT //PARALLELIZATION -- *\n  id,\n  timestamp,\n  text,\n  sentimentResult.sentiment AS sentiment,\n  sentimentResult.score AS sentimentScore\nFROM (\n  SELECT //PARALLELIZATION -- **\n    id,\n    timestamp,\n    text,\n    SentimentClassifierFactory.create(SentimentClassifierFactory.BASIC).classify(text) AS sentimentResult\n  FROM <parsed_tweets_table>\n) AS intermediate\n`\n          }\n          ]\n\n        },\n        'Spike Detection': {\n          query_list: [{\n            id: 1,\n            name: '1. Calculate Spike Detection',\n            operators: [\"source\", \"parser\", \"average calculator\", \"spike detector\", \"sink\"],\n            selectivities: [],  // TODO\n            hasWindows: true,\n            hasLateness: true,\n            query_plan: `-- Step 1: Parse the input data\nCREATE TABLE SensorMeasurement (\n  sensorId INT,\n  timestamp TIMESTAMP,\n  value DOUBLE\n);\n\nINSERT INTO SensorMeasurement\nSELECT\n  PARSE_JSON(data).sensorId AS sensorId,\n  PARSE_JSON(data).timestamp AS timestamp,\n  PARSE_JSON(data).value AS value\nFROM inputDataStream; //PARALLELIZATION -- *\n\n-- Step 2: Assign timestamps and watermarks\nCREATE TABLE SensorMeasurementWithWatermarks (\n  sensorId INT,\n  timestamp TIMESTAMP,\n  value DOUBLE,\n  watermark TIMESTAMP\n) WITH (\n  WATERMARK FOR timestamp AS timestamp - INTERVAL 'X' SECOND -- Specify the watermark strategy\n);\n\nINSERT INTO SensorMeasurementWithWatermarks\nSELECT\n  sensorId,\n  timestamp,\n  value,\n  timestamp - INTERVAL 'X' SECOND AS watermark\nFROM SensorMeasurement; //PARALLELIZATION -- **\n\n-- Step 3: Key the stream by sensorId\nCREATE TABLE KeyedSensorMeasurement (\n  sensorId INT,\n  timestamp TIMESTAMP,\n  value DOUBLE,\n  watermark TIMESTAMP\n) WITH (\n  WATERMARK FOR watermark AS watermark\n);\n\nINSERT INTO KeyedSensorMeasurement\nSELECT\n  sensorId,\n  timestamp,\n  value,\n  watermark\nFROM SensorMeasurementWithWatermarks;\n\n-- Step 4: Apply sliding processing time window\nCREATE TABLE WindowedSensorMeasurement AS (\n  SELECT\n    sensorId,\n    TUMBLE_START(timestamp, INTERVAL 'X' SECOND) AS windowStart,\n    TUMBLE_END(timestamp, INTERVAL 'X' SECOND) AS windowEnd,\n    AVG(value) AS averageValue\n  FROM KeyedSensorMeasurement\n  GROUP BY\n    sensorId,\n    TUMBLE(timestamp, INTERVAL 'X' SECOND)\n);\n\n-- Step 5: Filter spikes\nCREATE TABLE DetectedSpikes AS (\n  SELECT\n    sensorId,\n    windowStart,\n    windowEnd,\n    averageValue\n  FROM WindowedSensorMeasurement\n  WHERE ABS(value - averageValue) > 0.03 * averageValue\n); //PARALLELIZATION -- ***\n\n-- Step 6: Sink detected spikes\nINSERT INTO outputSink\nSELECT *\nFROM DetectedSpikes;\n`\n          }\n          ]\n\n\n        },\n        'Log Processing': {\n          query_list: [{\n            id: 1,\n            name: '1. Volume Counter',\n            operators: ['source', 'log-parser', 'volume counter', 'sink'],\n            selectivities: [],  // TODO\n            hasWindows: true,\n            query_plan: `SELECT\n    logTime,\n    COUNT(*) AS visitCount //PARALLELIZATION -- **\nFROM\n    (SELECT\n        logTime\n    FROM\n        LogEventTable\n    WHERE\n        logParserOutput = 'log-parser' //PARALLELIZATION -- *\n    ) AS filteredLogs\nGROUP BY\n    logTime;\n\n`\n          }, {\n            id: 2,\n            name: '2. Status Counter',\n            operators: ['source', 'log-parser', 'status counter', 'sink'],\n            selectivities: [],  // TODO\n            hasWindows: true,\n            query_plan: `SELECT\n    statusCode,\n    COUNT(*) AS statusCodeCount //PARALLELIZATION -- **\nFROM\n    (SELECT\n        statusCode\n    FROM\n        LogEventTable\n    WHERE\n        logParserOutput = 'log-parser' //PARALLELIZATION -- *\n    ) AS filteredLogs\nGROUP BY\n    statusCode;\n\n`\n          },\n          ]\n\n        },\n        'Trending Topics': {\n          query_list: [{\n            id: 1,\n            name: '1. Twitter trending topics',\n            operators: ['source', 'twitter-parser', 'topic-extractor', 'topic-popularity-detector', 'sink'],\n            selectivities: [],  // TODO\n            hasWindows: true,\n            hasThreshold: true,\n            query_plan: `INSERT INTO Topics (Topic, Count)\nSELECT SUBSTRING_INDEX(SUBSTRING_INDEX(word, ' ', 1), '#', -1) AS topic, COUNT(*) AS count //PARALLELIZATION -- ***\nFROM (\n    SELECT\n        REGEXP_REPLACE(SUBSTRING_INDEX(SUBSTRING_INDEX(t.TweetText, ' ', n.n), ' ', -1), '[^a-zA-Z0-9#]', '') AS word //PARALLELIZATION -- **\n    FROM\n        Tweets t\n    CROSS JOIN\n        (SELECT 1 AS n UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4) n -- Adjust the number of cross joins based on the maximum number of words per tweet\n    WHERE\n        t.TweetText LIKE '%#%' -- Filter tweets containing hashtags\n) subquery\nGROUP BY topic; //PARALLELIZATION -- *\n\n`\n          }\n          ]\n\n        },\n        'Bargain Index': {\n          query_list: [{\n            id: 1,\n            name: '1. Bargain-Index Calculator',\n            operators: [\"source\", \"quote-parser\", \"VWAP-operator\", \"bargain-index-calculator\", \"sink\"],\n            selectivities: [],  // TODO\n            hasWindows: true,\n            hasThreshold: true,\n            query_plan: `CREATE VIEW VWAP AS\nSELECT\n    symbol,\n    SUM(close * volume) / SUM(volume) AS vwap,  //PARALLELIZATION -- **\n    SUM(volume) AS totalVolume\nFROM\n    StockQuotes\nGROUP BY\n    symbol;\n\n-- Calculate bargain index and filter quotes\nSET @threshold = 0; -- Set your desired threshold value here  //PARALLELIZATION -- ***\nSELECT\n    q.symbol,\n    q.close,\n    q.volume\nFROM\n    StockQuotes q  //PARALLELIZATION -- *\nJOIN\n    VWAP v ON q.symbol = v.symbol\nWHERE\n    q.close / q.volume > @threshold;\n`\n          }\n          ]\n\n        },\n        'Click Analytics': {\n          query_list: [{\n            id: 1,\n            name: '1. Unique and total visits (timebased window)',\n            operators: [\"source\", \"click-log-parser\", \"repeat-visit\", \"reduce-operation\", \"sink\"],\n            selectivities: [],  // TODO\n            hasWindows: true,\n            hasThreshold: false,\n            query_plan: `SELECT url, COUNT(*) AS total_visits, \n            COUNT(DISTINCT user_id) AS unique_visits  //PARALLELIZATION -- **\nFROM ClickLogs //PARALLELIZATION -- *\nGROUP BY url; //PARALLELIZATION -- ***\n`\n          },{\n            id: 2,\n            name: '2. visits based on location',\n            operators: [\"source\", \"click-log-parser\", \"geography-visit\", \"sink\"],\n            selectivities: [],  // TODO\n            hasWindows: true,\n            hasThreshold: false,\n            query_plan: `SELECT \n  location.country,\n  COUNT(*) AS visits,\n  location.city,\n  COUNT(*) AS city_visits\nFROM ClickLogs //PARALLELIZATION -- *\nJOIN (\n  SELECT   //PARALLELIZATION -- **\n    ip_address,\n    MAX(city) AS city,\n    MAX(country) AS country\n  FROM GeoIPDatabase\n  GROUP BY ip_address\n) AS location ON ClickLogs.ip_address = location.ip_address\nGROUP BY location.country, location.city;\n`\n          },{\n            id: 3,\n            name: '3. Unique and total visits (countbased window)',\n            operators: [\"source\", \"click-log-parser\", \"repeat-visit\", \"reduce-operation\", \"sink\"],\n            selectivities: [],  // TODO\n            hasWindows: true,\n            hasThreshold: false,\n            query_plan: `SELECT url, COUNT(*) AS total_visits, \n            COUNT(DISTINCT user_id) AS unique_visits  //PARALLELIZATION -- **\nFROM ClickLogs //PARALLELIZATION -- *\nGROUP BY url; //PARALLELIZATION -- ***\n`\n          }]\n\n        },\n        'Linear Road': {\n          query_list: [{\n            id: 1,\n            name: '1. Toll Notification',\n            operators: [\"source\", \"Vehicle-event-parser\", \"toll-notification\", \"formatter-toll-notification\", \"sink\"],\n            selectivities: [],  // TODO\n            hasWindows: false,\n            hasThreshold: false,\n            query_plan: `SELECT\n    v.vehicleId,\n    COALESCE(SUM(t.tollAmount), 0) AS totalToll\nFROM\n    Vehicles v //PARALLELIZATION -- *\nLEFT JOIN\n    (\n        SELECT  //PARALLELIZATION -- **\n            vehicleId,\n            segmentId,\n            calculateToll(averageSpeed, numVehicles) AS tollAmount\n        FROM\n            (\n                SELECT //PARALLELIZATION -- ***\n                    segmentId,\n                    vehicleId,\n                    AVG(speed) AS averageSpeed,\n                    COUNT(*) AS numVehicles\n                FROM\n                    VehicleSpeedData\n                GROUP BY\n                    segmentId, vehicleId\n            ) subquery\n    ) t\nON\n    v.vehicleId = t.vehicleId\nGROUP BY\n    v.vehicleId\n\n`\n          },{\n            id: 2,\n            name: '2. Accident Notification',\n            operators: [\"source\", \"Vehicle-event-parser\", \"accident-notification\", \"formatter-accident-notification\", \"sink\"],\n            selectivities: [],  // TODO\n            hasWindows: true,\n            hasThreshold: false,\n            query_plan: `SELECT //PARALLELIZATION -- ***\n    eventTime,\n    CASE\n        WHEN COUNT(*) >= 3 THEN 'Accident Detected' //PARALLELIZATION -- **\n        ELSE 'No Accident'\n    END AS accidentStatus\nFROM\n    VehicleEvents //PARALLELIZATION -- *\nGROUP BY\n    SlidingWindow(eventTime, 5 minutes, 30 seconds)\n\n`\n          },{\n            id: 3,\n            name: '3. Daily Expenditure',\n            operators: [\"source\", \"Vehicle-event-parser\", \"daily-expenditure\", \"sink\"],\n            selectivities: [],  // TODO\n            hasWindows: false,\n            hasThreshold: false,\n            query_plan: `SELECT  //PARALLELIZATION -- **\n    vehicleId,\n    DATE(eventTime) AS expenditureDate,\n    SUM(expenditureAmount) AS dailyExpenditure\nFROM\n    VehicleEvents  //PARALLELIZATION -- *\nGROUP BY\n    vehicleId, DATE(eventTime)\n\n`\n          },{\n            id: 4,\n            name: '4. visits based on location',\n            operators: [\"source\", \"Vehicle-event-parser\", \"vehicle-report-mapper\", \"sink\"],\n            selectivities: [],  // TODO\n            hasWindows: false,\n            hasThreshold: false,\n            query_plan: `SELECT  //PARALLELIZATION -- **\n    vehicleId,\n    COUNT(*) AS totalReports\nFROM\n    VehicleEvents   //PARALLELIZATION -- *\nGROUP BY\n    vehicleId\n\n`\n          },\n          ]\n\n        },\n        'TPCH': {\n          query_list: [{\n            id: 1,\n            name: '1. Priority Order Counter (no window)',\n            operators: [\"source\", \"tpch-event-parser\", \"tpch-data-filter\", \"tpch-flat-mapper\", \"priority-counter\", \"sink\"],\n            selectivities: [],  // TODO\n            hasWindows: false,\n            hasThreshold: false,\n            query_plan: ``\n          },{\n            id: 2,\n            name: '1. Priority Order Counter (window)',\n            operators: [\"source\", \"tpch-event-parser\", \"tpch-data-filter\", \"tpch-flat-mapper\", \"priority-counter\", \"sink\"],\n            selectivities: [],  // TODO\n            hasWindows: true,\n            hasThreshold: false,\n            query_plan: `-- Filter and count orders with priorities between \"1-URGENT\" and \"5-LOW\"\nSELECT\n    o_orderpriority,\n    COUNT(*) AS orderCount  //PARALLELIZATION -- ***\nFROM\n    TPCHEvents //PARALLELIZATION -- *\nWHERE\n    o_orderpriority >= '1-URGENT' AND o_orderpriority <= '5-LOW' //PARALLELIZATION -- **\nGROUP BY\n    o_orderpriority\n\n`\n          }\n          ]\n\n        },\n        'Machine Outlier': {\n          query_list: [{\n            id: 1,\n            name: '1. Machine Outlier Detection',\n            operators: [\"source\", \"machine-usage-parser\", \"machine-usage-grouper\", \"outlier-detector\", \"sink\"],\n            selectivities: [],  // TODO\n            hasWindows: true,\n            hasThreshold: true,\n            query_plan: `\nSELECT\n    MachineId,\n    Timestamp,\n    UsageValue\nFROM\n    MachineUsageData  //PARALLELIZATION -- *\nWHERE  \n    Timestamp >= (CurrentTimestamp - SlidingWindowSize) //PARALLELIZATION -- **\n    AND Timestamp <= CurrentTimestamp \nGROUP BY\n    MachineId, Timestamp\nHAVING    \n    COUNT(*) = 1    //PARALLELIZATION -- ***\n\n`\n          }\n          ]\n\n        },\n        'Traffic Monitoring': {\n          query_list: [{\n            id: 1,\n            name: '1. Traffic Monitor',\n            operators: [\"source\", \"traffic-event-parser\", \"road-matcher\", \"avg-speed\",\"formatter\", \"sink\"],\n            selectivities: [],  // TODO\n            hasWindows: true,\n            hasThreshold: false,\n            query_plan: `\n\n-- Step 1: Parse Traffic Events\nSELECT        //PARALLELIZATION -- *\n    TrafficEventId,\n    Timestamp,\n    VehicleId,\n    RoadId,\n    Speed\nFROM\n    TrafficEvents;\n\n-- Step 2: Road Matching\nWITH RoadMatch AS (         //PARALLELIZATION -- **\n    SELECT\n        TrafficEventId,\n        Timestamp,\n        VehicleId,\n        RoadId\n    FROM\n        ParsedTrafficEvents\n    WHERE\n        RoadId IS NOT NULL\n),\n\n-- Step 3: Calculate Average Speed\nAvgSpeed AS (           //PARALLELIZATION -- ***\n    SELECT\n        RoadId,\n        AVG(Speed) AS AverageSpeed\n    FROM\n        RoadMatch\n    GROUP BY\n        RoadId\n),\n\n-- Step 4: Format Results\nFormattedResults AS (         //PARALLELIZATION -- ****\n    SELECT\n        RoadId,\n        AverageSpeed\n    FROM\n        AvgSpeed\n    WHERE\n        AverageSpeed > 0\n)\n\n-- Step 5: Output Results (Sink)\nINSERT INTO\n    TrafficResults\nSELECT\n    RoadId,\n    AverageSpeed\nFROM\n    FormattedResults;\n\n`\n          }\n          ]\n\n        },\n      },\n      job_input: ['File', 'Kafka'],\n      f_job_class_name: '',\n      f_job_enumeration_strategy: 'None',\n      f_job_iteration_strategy: 'From Top',\n      f_job_custom_strategy: \"10,10,10,40\\n20,20,20,40\\n30,30,30,40\\n40,40,40,40\",\n      f_job_num_operators: \"0\",\n      f_job_query_name: '',\n      f_job_class_input_type: '',\n      f_job_class_input: '',\n      f_job_class_input_min: 100000,\n      f_job_class_input_max: 1000000,\n      f_parallelization_degree: [],\n      f_parallelization_degree_min: [],\n      f_parallelization_degree_max: [],\n      f_parallelization_degree_steps: [],\n      f_selectivities: [],\n      f_job_window_size: 100,\n      f_job_window_size_min: 10,\n      f_job_window_size_max: 1000,\n      f_job_window_slide_size: 10,\n      f_job_window_slide_size_min: 5,\n      f_job_window_slide_size_max: 20,\n      f_job_google_lateness: 0,\n      f_job_run_time: 6,\n      f_job_threshold: 5,\n      f_num_of_times_job_run: 1,\n      f_job_iterations: 100,\n      show_progress: false,\n\n\n    }\n  },\n  // \n  // \n  methods: {\n    async createJob() {\n      this.showProgress = true;\n      var num = this.job_queries[this.f_job_class_name].query_list[this.f_job_query_name - 1].operators.length\n      if (this.f_parallelization_degree.length != num) {\n          this.f_parallelization_degree = Array.from('0'.repeat(num))\n      }\n      if (this.f_parallelization_degree_steps.length != num) {\n          this.f_parallelization_degree_steps = Array.from('1'.repeat(num))\n      }\n      var data = {\n        \"job_class\": this.f_job_class_name,//'Ad Analytics'\n        \"job_enumeration_strategy\": this.f_job_enumeration_strategy,\n        \"job_class_input_type\": this.f_job_class_input_type, //'Kafka'\n        \"job_class_input\": this.f_job_class_input, //kafka event rate\n        \"job_class_input_min\": this.f_job_class_input_min,\n        \"job_class_input_max\": this.f_job_class_input_max,\n        \"job_query_name\": this.f_job_query_name, //'1'\n        \"job_pds\": this.f_parallelization_degree,//[1,3,5,1,3]\n        \"job_pds_min\": this.f_parallelization_degree_min,//[1,3,5,1,3]\n        \"job_pds_max\": this.f_parallelization_degree_max,//[1,3,5,1,3]\n        \"job_pds_steps\": this.f_parallelization_degree_steps,//[1,1,1,1,1]\n        \"job_selectivities\": this.f_selectivities,//[1,3,5,1,3]\n        \"job_window_size\": this.f_job_window_size,\n        \"job_window_size_min\": this.f_job_window_size_min,\n        \"job_window_size_max\": this.f_job_window_size_max,\n        \"job_window_slide_size\": this.f_job_window_slide_size,\n        \"job_window_slide_size_min\": this.f_job_window_slide_size_min,\n        \"job_window_slide_size_max\": this.f_job_window_slide_size_max,\n        \"job_run_time\": this.f_job_run_time,\n        \"job_google_lateness\": this.f_job_google_lateness,\n        \"job_threshold\": this.f_job_threshold,\n        \"num_of_times_job_run\": this.f_num_of_times_job_run,\n        \"job_iterations\": this.f_job_iterations,\n        \"job_iteration_strategy\": this.f_job_iteration_strategy,\n        \"job_custom_strategy\": this.f_job_custom_strategy,\n      }\n      console.log('providing job with these parameters')\n      console.log(data)\n\n      var endpoint = this.url + \":8000/infra/jobcreate/\" + this.cluster_id;\n\n      axios\n        .post(endpoint, data)\n        .then((resp) => {\n          this.showProgress = false\n          console.log(resp.data)\n        })\n        .catch((err) => {\n          console.log(err)\n        })\n    },\n    async startCluster() {\n      await axios\n        .get(this.url + \":8000/infra/start/\" + this.id)\n        .then((resp) => {\n          this.snackbar = {\n            view: true,\n            timeout: 3000,\n            text: 'Started the cluster successfully',\n            color: 'primary'\n          };\n          console.log(resp)\n          this.refresh(this.id)\n          this.$emit('refresh', 'refreshed')\n        })\n    },\n    async stopCluster() {\n      await axios\n        .get(this.url + \":8000/infra/stop/\" + this.id)\n        .then((resp) => {\n\n          console.log(resp)\n          this.refresh(this.id)\n          this.snackbar = {\n            view: true,\n            timeout: 3000,\n            text: 'Stopped the cluster successfully',\n            color: 'primary'\n          };\n          this.$emit('refresh', 'refreshed')\n        })\n    },\n    async refresh(cluster_identifier) {\n      await axios\n        .get(this.url + \":8000/infra/getCluster/\" + cluster_identifier)\n        .then((resp) => {\n          this.cluster_id = resp.data.id;\n          this.cluster_name = resp.data.name;\n          this.cluster_status = resp.data.status;\n          console.log(resp)\n        })\n    },\n    async changeEnumStrategy() {\n        var base = 5;\n        var num = this.job_queries[this.f_job_class_name].query_list[this.f_job_query_name - 1].operators.length;\n        this.f_job_num_operators = num;\n        this.f_job_custom_strategy = \"\";\n        for (let i = 0; i < 8; i++) {\n            // generate pds\n            var pds = \"\";\n            for (let j = 0; j < num; j++) {\n                if (j != 0) {\n                    pds += \",\";\n                }\n                pds += base * (i+1);\n                console.log(pds);\n            }\n\n            // add pds as new line\n            if (i != 0) {\n                this.f_job_custom_strategy += \"\\n\";\n            }\n            this.f_job_custom_strategy += pds;\n        }\n    },\n    async changeQuery() {\n      this.f_selectivities = this.job_queries[this.f_job_class_name].query_list[this.f_job_query_name - 1].selectivities\n      console.log(this.f_selectivities)\n      this.changeEnumStrategy();\n    }\n\n  },\n  computed: {\n    snackbar: {\n      get() {\n        return this.$store.state.snackbar;\n      },\n      set(value) {\n        this.$store.commit('setSnackbar', value);\n      },\n    },\n    getSelectedQueryPlan() {\n\n      const queryIndex = this.f_job_query_name - 1;\n      let queryPlan = this.job_queries[this.f_job_class_name].query_list[queryIndex].query_plan;\n      console.log('reached main')\n      if(this.f_job_class_name == 'Smart Grid' && (this.f_job_query_name == 1 || this.f_job_query_name == 2)){\n        console.log('reacheed inside smart grid')\n\n        let newQuery = '//PARALLELIZATION --'+ this.f_parallelization_degree[0]\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery)\n        console.log(queryPlan);\n\n      }else if(this.f_job_class_name == 'Ad Analytics' && this.f_job_query_name == 1){\n\n\n        let newQuery1 = '//PARALLELIZATION --'+ this.f_parallelization_degree[0]\n        let newQuery2 = '//PARALLELIZATION --'+ this.f_parallelization_degree[1]\n        let newQuery3 = '//PARALLELIZATION --'+ this.f_parallelization_degree[2]\n        let newQuery4 = '//PARALLELIZATION --'+ this.f_parallelization_degree[3]\n        let newQuery5 = '//PARALLELIZATION --'+ this.f_parallelization_degree[4]\n\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1)\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2)\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- ***', newQuery3)\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- ****', newQuery4)\n        queryPlan = queryPlan.replace('//PARALLELIZATION -- *****', newQuery5)\n\n      }else if(this.f_job_class_name == 'Google cloud Monitoring' && (this.f_job_query_name == 1 || this.f_job_query_name == 2)){\n\n\nlet newQuery1 = '//PARALLELIZATION --'+ this.f_parallelization_degree[0]\nlet newQuery2 = '//PARALLELIZATION --'+ this.f_parallelization_degree[1]\n\n\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2)\n\n\n}else if(this.f_job_class_name == 'Sentiment Analysis' && this.f_job_query_name == 1){\n\n\nlet newQuery1 = '//PARALLELIZATION --'+ this.f_parallelization_degree[0]\nlet newQuery2 = '//PARALLELIZATION --'+ this.f_parallelization_degree[1]\n\n\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2)\n\n\n}else if(this.f_job_class_name == 'Spike Detection' && this.f_job_query_name == 1){\n\n\nlet newQuery1 = '//PARALLELIZATION --'+ this.f_parallelization_degree[0]\nlet newQuery2 = '//PARALLELIZATION --'+ this.f_parallelization_degree[1]\nlet newQuery3 = '//PARALLELIZATION --'+ this.f_parallelization_degree[2]\n\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- ***', newQuery3)\n\n\n}else if(this.f_job_class_name == 'Log Processing' && (this.f_job_query_name == 1 || this.f_job_query_name == 2)){\n\n\nlet newQuery1 = '//PARALLELIZATION --'+ this.f_parallelization_degree[0]\nlet newQuery2 = '//PARALLELIZATION --'+ this.f_parallelization_degree[1]\n\n\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2)\n\n\n\n}else if(this.f_job_class_name == 'Trending Topics' && this.f_job_query_name == 1){\n\n\nlet newQuery1 = '//PARALLELIZATION --'+ this.f_parallelization_degree[0]\nlet newQuery2 = '//PARALLELIZATION --'+ this.f_parallelization_degree[1]\nlet newQuery3 = '//PARALLELIZATION --'+ this.f_parallelization_degree[2]\n\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- ***', newQuery3)\n\n\n}else if(this.f_job_class_name == 'Bargain Index' && this.f_job_query_name == 1){\n\n\nlet newQuery1 = '//PARALLELIZATION --'+ this.f_parallelization_degree[0]\nlet newQuery2 = '//PARALLELIZATION --'+ this.f_parallelization_degree[1]\nlet newQuery3 = '//PARALLELIZATION --'+ this.f_parallelization_degree[2]\n\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- ***', newQuery3)\n\n\n}else if(this.f_job_class_name == 'Click Analytics' && this.f_job_query_name == 1){\n\n\nlet newQuery1 = '//PARALLELIZATION --'+ this.f_parallelization_degree[0]\nlet newQuery2 = '//PARALLELIZATION --'+ this.f_parallelization_degree[1]\nlet newQuery3 = '//PARALLELIZATION --'+ this.f_parallelization_degree[2]\n\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- ***', newQuery3)\n\n}else if(this.f_job_class_name == 'Click Analytics' && this.f_job_query_name == 2){\n\nlet newQuery1 = '//PARALLELIZATION --'+ this.f_parallelization_degree[0]\nlet newQuery2 = '//PARALLELIZATION --'+ this.f_parallelization_degree[1]\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2)\n}else if(this.f_job_class_name == 'Linear Road' && this.f_job_query_name == 1 ){\n\n\nlet newQuery1 = '//PARALLELIZATION --'+ this.f_parallelization_degree[0]\nlet newQuery2 = '//PARALLELIZATION --'+ this.f_parallelization_degree[1]\nlet newQuery3 = '//PARALLELIZATION --'+ this.f_parallelization_degree[2]\n\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- ***', newQuery3)\n\n\n}else if(this.f_job_class_name == 'Linear Road' && this.f_job_query_name == 2 ){\n\n\nlet newQuery1 = '//PARALLELIZATION --'+ this.f_parallelization_degree[0]\nlet newQuery2 = '//PARALLELIZATION --'+ this.f_parallelization_degree[1]\nlet newQuery3 = '//PARALLELIZATION --'+ this.f_parallelization_degree[2]\n\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- ***', newQuery3)\n\n\n}else if(this.f_job_class_name == 'Linear Road' && (this.f_job_query_name == 3 || this.f_job_query_name == 4)){\n\nlet newQuery1 = '//PARALLELIZATION --'+ this.f_parallelization_degree[0]\nlet newQuery2 = '//PARALLELIZATION --'+ this.f_parallelization_degree[1]\n\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2)\n\n}else if(this.f_job_class_name == 'TPCH' && this.f_job_query_name == 1){\n\n\nlet newQuery1 = '//PARALLELIZATION --'+ this.f_parallelization_degree[0]\nlet newQuery2 = '//PARALLELIZATION --'+ this.f_parallelization_degree[1]\nlet newQuery3 = '//PARALLELIZATION --'+ this.f_parallelization_degree[2]\n\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- ***', newQuery3)\n\n\n}else if(this.f_job_class_name == 'Machine Outlier' && this.f_job_query_name == 1){\n\n\nlet newQuery1 = '//PARALLELIZATION --'+ this.f_parallelization_degree[0]\nlet newQuery2 = '//PARALLELIZATION --'+ this.f_parallelization_degree[1]\nlet newQuery3 = '//PARALLELIZATION --'+ this.f_parallelization_degree[2]\n\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- ***', newQuery3)\n\n\n}else if(this.f_job_class_name == 'Traffic Monitoring' && this.f_job_query_name == 1){\n\n\nlet newQuery1 = '//PARALLELIZATION --'+ this.f_parallelization_degree[0]\nlet newQuery2 = '//PARALLELIZATION --'+ this.f_parallelization_degree[1]\nlet newQuery3 = '//PARALLELIZATION --'+ this.f_parallelization_degree[2]\n\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- *', newQuery1)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- **', newQuery2)\nqueryPlan = queryPlan.replace('//PARALLELIZATION -- ***', newQuery3)\n\n\n}\n      return queryPlan\n    },\n    getSelectedQueryList() {\n\n\nreturn this.job_queries[this.f_job_class_name].query_list\n}\n  },\n  async mounted() {\n\n    this.refresh(this.id)\n\n\n  },\n  watch: {\n    id(new_val, old_val) {\n      if (new_val != old_val)\n        this.refresh(this.id)\n    }\n  }\n}\n</script>\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}